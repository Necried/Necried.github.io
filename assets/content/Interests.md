<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1. Preface</a></li>
<li><a href="#sec-2">2. Academic Interests</a>
<ul>
<li><a href="#sec-2-1">2.1. Functional Programming</a></li>
<li><a href="#sec-2-2">2.2. Category Theory</a></li>
<li><a href="#sec-2-3">2.3. Competitive Programming</a></li>
</ul>
</li>
</ul>
</div>
</div>

# Preface<a id="sec-1" name="sec-1"></a>

This page serves to document my current interests, both academic and hobbyist in nature.
I've used Emacs `org-mode` to structure this page, partially because of my desire to
learn and apply `org-mode` , but also because of `org-mode`'s flexibility of layout
and document compilation options.

# Academic Interests<a id="sec-2" name="sec-2"></a>

The areas of interests below may appear varied, but they are in alignment with my
common goals in Computer Science. 

## Functional Programming<a id="sec-2-1" name="sec-2-1"></a>

The cornerstone of my programming interest, I've self-taught myself Haskell in 2018 and
never looked back. I like to believe that the functional paradigm has its place in mainstream
programming because of its emphasis on types and functions, two key concepts in programming.
My current focus on functional programming is listed below, and is by no means an exhaustive
list:
-   Dependent types
-   Relationships between abstract math theory and functional programming
-   Applications of the functional paradigm in real world applications

## Category Theory<a id="sec-2-2" name="sec-2-2"></a>

An abstract mathematical theory deserving its own special mention. Category Theory offers an
alternative to Set Theory, and is concerned with the `composition` of objects, which I believe
is a core concept in Computer Science. I am particularly interested in the use of
Category Theory in real-life applications.

## Competitive Programming<a id="sec-2-3" name="sec-2-3"></a>

Introduced to me in 2018, I am purely interested in Competitive Programming because of its
rigorous demand of applying algorithms and data structures to solve problems. This is my 
bridge between the (sometimes) more abstract nature of functional programming and the more
pragmatic nature of programming in the real-world. It doesn't hurt that competitive programming
helps with training for technical interviews.